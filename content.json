{"meta":{"title":"Lemon's Blog","subtitle":null,"description":null,"author":"Lemon","url":"http://lemon23.me"},"pages":[],"posts":[{"title":"排序算法之插入排序","slug":"排序算法之插入排序","date":"2016-11-28T07:03:11.000Z","updated":"2016-11-29T09:06:44.000Z","comments":true,"path":"2016/11/28/排序算法之插入排序/","link":"","permalink":"http://lemon23.me/2016/11/28/排序算法之插入排序/","excerpt":"插入排序同样是排序算法，它和上一篇所说的”选择排序”到底有什么区别呢？又该在什么情况下使用插入排序呢？带着疑问开始学习，在学习中尝试解答，我觉得这是一个好的学习方法。(^-^)","text":"插入排序同样是排序算法，它和上一篇所说的”选择排序”到底有什么区别呢？又该在什么情况下使用插入排序呢？带着疑问开始学习，在学习中尝试解答，我觉得这是一个好的学习方法。(^-^) 插入排序插入排序，顾名思义是将元素插入到有序数组中的适当位置中。 规则将 N 个元素的数列分为已有序和无序两个部分；每次处理将无序数列的第一个元素与有序数列的元素从后往前逐个比较；插入适当位置。 时间复杂度对于随机排列的长度为 N 且值不重复的数组，最坏情况下（降序排列）需要 N^2/2 次比较和 N^2/2 次交换；最好情况（已经是升序排列）需要 N-1 次比较和 0 次交换。 平均来说，插入排序的时间复杂度为 O(n^2)。 优缺点 所需的时间取决于数组元素的初始顺序。当用插入排序排列一组有序数组或所有元素值相同的数组时，插入排序能够立即发现每个元素都已经在合适的位置上，它的运行时间是线性的。 稳定性。插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当刚开始时只有一个元素，即第一个元素。比较是从有序序列的末尾开始的，要插入的元素和有序列表的最大数开始比起，如果比它大则插入其后面，否则一直往前找到适当的位置插入。如果元素相等，那么要插入的元素会放在相等元素后面，所以相等元素的前后顺序是没有改变的。 算法实现js代码example.js1234567891011121314function insert_sort(arr) &#123; var temp, i, j; for (i = 0; i &lt; arr.length; i++)&#123; temp = arr[i]; j = i - 1; while((j &gt;= 0) &amp;&amp; (arr[j] &gt; temp)) &#123; arr[j+1] = arr[j]; j--; &#125;; if (j != i-1) &#123; arr[j+1] = temp; &#125;; &#125;;&#125;; 分析我给insert_sort()函数增加几行 console 打印出在循环内各个参数值和数组的变化，这样可以更直观的了解到函数是如何一步步给数组排序的。 接着来看一下函数到底打印的结果： 我来一步步的解析insert_sort()函数的排序过程，当中究竟发生了什么： 我给出了数组arr=[4,2,9,5,2]，共 5 个元素的数组，所以总的外循环次数也应为 5 次。对于 0 到 N-1 之间的每个 i ，将 a[i] 与 a[0] 到 a[i-1]中比它小的所有元素依次有序地交换，i 左侧的元素总是有序的。 第一轮循环 我们对照着上面的函数来看，进入for循环时，i = 0，temp = 4，j = -1；然后到达while循环处进行判断：-1 &gt;= 0 就已经不成立了，所以直接跳过while循环；接下来到达if判断处：-1 != -1 也不成立，跳过if直接输出 “4—“。这一步的作用就是把数组第一个元素插入到有序数组中，因为刚开始插入，有序数组并没有值，所以直接把无序数组第一元素插入就好，并不用判断大小。至此，数组为：[4,2,9,5,2] 第二轮循环 此时，i = 1，temp = 2，j = 0；到达while循环判断：0 &gt;= 0 和 4 &gt; 2 成立，进入while循环执行：2 = 4, j = -1，到此 j 已经不符合while循环的判断，所以不再继续循环；然后是if判断：-1 != 0 成立，执行：4 = 2；结束，输出 “4—“，这一步把无序数组的第一个元素 2 与 有序数组的最后一个元素 4 作比较，2 &lt; 4 ，所以在内循环中把 4 向右移动一位，又在if中把 2 插入到有序数组的第一位置。至此， 数组为：[2,4,9,5,2] 第三轮循环 此时，i = 2, temp = 9, j = 1；来到while循环进行判断：1 &gt;= 0 和 4 &gt; 9，显然第二个表达式并不成立，所以跳过while循环；接着是if判断：1 != 1 也不成立，跳过，直接输出 “4—“。这一步取出无序数组的第一元素 9 ，与有序列表的最后一个元素 4 比较，4 &lt; 9，所以直接把 9 放到 4 的后面位置即可。至此，数组为：[2,4,9,5,2] 第四轮循环 此时，i = 3, temp = 5, j = 2；到了while循环判断：2 &gt;= 0 和 9 &gt; 5 成立，执行：5 = 9，j = 1；继续while判断：1 &gt;= 0 和 4 &gt; 5，第二表达式不成立，不再继续while循环；直接到if判断：1 ！= 2 成立，执行：9 = 5；这一步把无序数组第一元素 5 和有序数组 9 作比较，5 &lt; 9 所以元素 9 向右移动一位，又判断了 5 &lt; 4 但不成立，所以元素 5 就插入到 9 之前的位置。至此，数组为：[2,4,5,9,2] 第五轮循环 此时，i = 4，temp = 2, j = 3;又进行while循环判断：3 &gt;= 0 和 9 &gt; 2 成立，执行：2 = 9, j = 2;继续while判断：2 &gt;= 0 和 5 &gt; 2 成立，执行：9 = 5, j = 1;继续while判断：1 &gt;= 0 和 4 &gt; 2 成立，执行：5 = 4, j = 0;继续while判断：0 &gt;= 0 和 2 &gt; 2 第二表达式不成立，跳出while循环；接着是if判断：0 != 3 成立，执行：4 = 2;这一步无序数组只剩下 2 ，它依次与有序数组的 9、5、4、2比较，最终插入到 4 的前面，元素 4、5、9 都依次向右移动了一位。最终，数组为：[2,2,4,5,9] 自己把数组带入函数内，一步步的记下各个事态会让整个思路都清晰的，也能更清楚参数的变化和数组元素的移动。所以我每次都会用一个很短的数组自己手动执行一次函数，写出每时每刻的值，这样可以更好的让算法带领你一步步的移动元素、排列数组。 比较插入排序和选择排序同样是排序算法，那么到底哪种排序算法更快呢？ 选择排序无论数组是正序还是倒序排列，都要整体扫描一遍数组，而插入排序可以很快发现数字是否已在合适位置上。那么理论上插入排序应该比选择排序快，到底这个理论正不正确，我需要通过实践来验证它： 我写了两个验证函数——t1()和t2()。（验证函数源代码地址写在最后的参考文档中）这两个函数的作用都是根据传入参数 count，生成 count 组由 0 到 10 随机生成的 10 位数数组，然后计算其开始时间到结束时间的差，并分别使用插入排序和选择排序排列随即数组，看看到底哪种算法更快。 结果：上图中，我打印出了两种排序算法的运行时间，可以看出插入排序所用时间比选择排序快一点的。虽然我传入了 100000 ，也就是生成 100000 组随机数数组，但单位是毫秒，也就是两种算法平均有0.04秒的差距，实际肉眼可见差距并不大，如果我不打印出时间来是感觉不到的。 下面我更改一下两个函数，生成由 0 到 100 随机生成的 100 位数数组，这样工作量应该大了不少，我们再来看一下两个函数的运行时间：这次我只实验了三组数据，因为已经明显感觉到等待的时间了。这次选择排序的运行时间最高达到了 11586 毫秒，也就是有 11秒5 的时间在是计算中。你可以自己数 11 秒种，就能体会运行时间有多长了。 当然，这只是基于随即数组进行的实验，有兴趣的可以基于正序、倒序、元素值相同的数组进行测试。 所以，结论是 在随机数数组中，插入排序比选择排序执行速度更快 。 参考文档 图灵程序设计丛书–算法(第4版) 插入排序函数源代码 (github/Lemon23/Algorithms-Lib/Sort Algorithm/) 验证函数源代码","categories":[{"name":"技术","slug":"技术","permalink":"http://lemon23.me/categories/技术/"},{"name":"算法","slug":"技术/算法","permalink":"http://lemon23.me/categories/技术/算法/"}],"tags":[{"name":"初级算法","slug":"初级算法","permalink":"http://lemon23.me/tags/初级算法/"},{"name":"排序","slug":"排序","permalink":"http://lemon23.me/tags/排序/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://lemon23.me/categories/技术/"},{"name":"算法","slug":"技术/算法","permalink":"http://lemon23.me/categories/技术/算法/"}]},{"title":"排序算法之选择排序","slug":"排序算法之选择排序","date":"2016-11-25T06:47:47.000Z","updated":"2016-11-29T09:00:45.000Z","comments":true,"path":"2016/11/25/排序算法之选择排序/","link":"","permalink":"http://lemon23.me/2016/11/25/排序算法之选择排序/","excerpt":"算法是每一个程序员都应该了解的知识，正所谓：不会算法的程序员人生是不完整的。排序算法是算法界的基础了，并且在各种面试中被问到最多的算法题就是排序了，所以先来理解排序算法中初级的排序——选择排序。","text":"算法是每一个程序员都应该了解的知识，正所谓：不会算法的程序员人生是不完整的。排序算法是算法界的基础了，并且在各种面试中被问到最多的算法题就是排序了，所以先来理解排序算法中初级的排序——选择排序。 排序排序，就是将一组对象按照某种逻辑顺序重新排列的过程，其目的就是将一组”无序”的记录序列调整为”有序”的记录序列。 假定，在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变（即在排序前，a[i]=a[i+1]，排序后他们的位置是不变的），则称这种排序算法是稳定的，否则为不稳定排序。 排序算法分为很多种，常见的有：快速排序、希尔排序、堆排序、选择排序、插入排序和归并排序等… 选择排序一种极简单的排序算法。 规则首先，找到数组中最小的那个元素；其次，将它和数组的第一个元素交换位置；再次，在剩下的元素中找到最小的元素，将它与第二个元素交换位置；如此反复，直到将整个数组排序。 时间复杂度选择排序的内循环只是在比较当前元素与已知的最小元素（以及将当前索引加1和检查是否代码越界）。交换元素的代码写在内循环之外，每次交换都排定一个元素。 交换操作介于 0 和 (n-1) 次之间，比较操作为 n(n-1)/2 次，赋值操作介于 0 和 3(n-1) 次之间。 因此，比较次数 O(n^2)，交换的总次数是 O(n) ，算法的时间效率取决于比较的次数。 优缺点 运行时间和输入无关，为了找出最小的元素，它需要先整体扫描一遍数组，但这并不能为之后的迭代提供什么信息。所以如果有一组有序的数组或值全部相等的数组和一个无序数组所用的排序时间是一样长的。 数据移动少，每次交换都会改变两个数组元素的值，因此选择排序用了 N 次交换（交换次数和数组的大小是线性关系）。其他任何算法都是线性对数或平方级别。 算法实现js代码example.js123456789101112131415function sort(arr) &#123; var temp; var pos = 0; for (var i = 0; i &lt; arr.length-1; i++) &#123; pos = i; for (var j = i+1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[pos]) &#123; pos = j; &#125;; &#125;; temp = arr[i]; arr[i] = arr[pos]; arr[pos] = temp; &#125;;&#125;; 分析为了体现选择排序的实现过程，输出最终的由小到大的排序数组，我在上面的代码中加入了一些打印语句，方便我可以直观的看到sort()函数是如何遍历并且交换元素的。 可以看出，我打印出了每次参数的变化情况，接下来我们来看看在sort()函数内究竟发生了什么： 第一次循环会遍历整个数组，此时 i = 0，逐个比较元素后找到最小值，并把最小元素下标赋值给 pos，在执行到 st.6 时数组第 i 位置的元素和第 pos 位置的元素互相交换位置，也就是把最小值移到了数组第一位。 第二次循环 i = 1，此时遍历会排除数组第 i 位置左边的元素，也就是排除了第一位置的元素再开始遍历。比较其余数字后，同样把最小元素下标赋值给 pos，最后把数组第 i 位置元素和第 pos 位置元素互换位置，也就是把最小值移到了第二位。此时，因为数组中本身第二位置元素就是当前最小值了，所以在打印中看不出元素交换的痕迹，但是代码确实是执行了一次交换赋值，只不过是把第二位又移到了第二位。 第三次循环和第四次循环跟上面步骤一样。最后输出排列好的数组。 从上图就可以看出，选择排序的排序轨迹成对角线状，而无论下一元素是否已经按大小排列好，它都要遍历剩余元素做比对后交换位置。所以，如果你有一组已经排列好的数组，或排列变动并不大的数组，使用选择排序是很不划算的。 并且，选择排序是一种不稳定排序，它会打乱你数组中相同元素的位置。比如：[9,5,9,3,1]排序这个数组会先把第一元素’9’与最后一个元素’1’交换，这时本应在第三个元素的’9’就会排在它前面。当然，在视觉上是无所谓的，但是稳定排序就不会出现这样的问题。 参考文档 图灵程序设计丛书–算法(第4版) 选择排序函数源代码 (github/Lemon23/Algorithms-Lib/Sort Algorithm/)","categories":[{"name":"技术","slug":"技术","permalink":"http://lemon23.me/categories/技术/"},{"name":"算法","slug":"技术/算法","permalink":"http://lemon23.me/categories/技术/算法/"}],"tags":[{"name":"初级算法","slug":"初级算法","permalink":"http://lemon23.me/tags/初级算法/"},{"name":"排序","slug":"排序","permalink":"http://lemon23.me/tags/排序/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://lemon23.me/categories/技术/"},{"name":"算法","slug":"技术/算法","permalink":"http://lemon23.me/categories/技术/算法/"}]},{"title":"Soft-Cat","slug":"Soft-Cat","date":"2016-11-02T05:04:03.000Z","updated":"2016-11-02T09:32:05.000Z","comments":true,"path":"2016/11/02/Soft-Cat/","link":"","permalink":"http://lemon23.me/2016/11/02/Soft-Cat/","excerpt":"自主设计构建的一个”关爱流浪猫”官网的封面页。","text":"自主设计构建的一个”关爱流浪猫”官网的封面页。 我们先来看一下页面效果： 页面描述页面整体为 “现代 欧美 清新 简约” 的风格。 进入网站最夺人眼球的是网站中间用白色粗体的大字凸显出的网站主旨——“Soft Cat”，其次就是符合主题的背景图，我选用了一只躺在毛毯上的小猫，同时为背景作了半透明处理，为了用户能够看清白色的文字。 网站整体的颜色再搭配文字，给用户的第一感觉是简约又大方，而纯净的页面中那粉色的心形标志就更显得夺目，使用户会不由自主的把目光移到那里。 简单的页面就要搭配少量的文字，字多了排版也是问题，而且用户会产生反感，不想去阅读和浏览。我通过文字的大小粗细进行排版，使用户能很快的分清楚文字的布局，从少量的文字中明白这个网站是干什么的！ 现在我分解展示一下这个网站的各个部分： LOGO网站Logo我用了我自己的名字，并没有加入图片，因为这个字体已经很好看了。一个页面的Logo是很重要的，它是网站的门面，也是别人能否记住你是谁的决定性因素！这里我使用了Pacifico字体，并且在字母间作了间隔，目的是可以让用户更清楚的看到每个字母并记住它。index.css123font-family: Pacifico, Snell Roundhand;font-weight: 500;letter-spacing: 3px; Nav 网站导航也是很重要的，要让用户能够看明白导航可以带他去到哪里，和我身处什么位置。相对于这种简洁的页面，导航需要至少两种状态：鼠标移上和点击后。 下面是这两种状态的样式效果： 页面层次多的最好使用”面包屑”导航，或者在这个基础上构建二级导航，给用户一个好的浏览体验。 主体这个部分是网站的精髓所在，你要告诉用户，这是关于什么的网站？可以干什么？它包括了网站的主旨、标语、关爱语和心型按钮： 在样式中，我使用了flex布局，可以响应各种尺寸的屏幕，用过一次就爱上了它。页面中的文字可以根据实际情况做更改，样式布局也可以随心所欲，重点是在没有使用边框的时候，你应该能让用户区分出文字的排版。 在页面中我添加了一个小动效，使网站使用起来不枯燥。就是粉色的心型按钮，点击后会3D旋转三圈，然后提示用户”Thank for you”。无论在使用中它的作用是筹款，还是点赞，我只是无聊添加个小玩意。可以看源代码，其实只有6行。 源文件文件地址：Github-Lemon23/Pages/Soft Cat 如果你喜欢这个页面的话，给个赞吧！","categories":[{"name":"设计","slug":"设计","permalink":"http://lemon23.me/categories/设计/"},{"name":"网页构建","slug":"设计/网页构建","permalink":"http://lemon23.me/categories/设计/网页构建/"}],"tags":[{"name":"欧美","slug":"欧美","permalink":"http://lemon23.me/tags/欧美/"},{"name":"清新","slug":"清新","permalink":"http://lemon23.me/tags/清新/"},{"name":"简约","slug":"简约","permalink":"http://lemon23.me/tags/简约/"},{"name":"动物","slug":"动物","permalink":"http://lemon23.me/tags/动物/"},{"name":"封面页","slug":"封面页","permalink":"http://lemon23.me/tags/封面页/"}],"keywords":[{"name":"设计","slug":"设计","permalink":"http://lemon23.me/categories/设计/"},{"name":"网页构建","slug":"设计/网页构建","permalink":"http://lemon23.me/categories/设计/网页构建/"}]},{"title":"Vue关于data数据的深度响应原理","slug":"Vue关于data数据的深度响应原理","date":"2016-10-26T03:48:25.000Z","updated":"2016-10-26T07:41:58.000Z","comments":true,"path":"2016/10/26/Vue关于data数据的深度响应原理/","link":"","permalink":"http://lemon23.me/2016/10/26/Vue关于data数据的深度响应原理/","excerpt":"前些日子在写Vue的时候遇到了一个问题，虽然最后修改好了。但是浅尝辄止不是我的性格。所以在工作之余，自己找寻了一下问题的原因，顺便研究了一下Vue的深度响应原理。","text":"前些日子在写Vue的时候遇到了一个问题，虽然最后修改好了。但是浅尝辄止不是我的性格。所以在工作之余，自己找寻了一下问题的原因，顺便研究了一下Vue的深度响应原理。 发现问题并产生疑问问题描述任务需求：创建一个用户填写信息的表单页面，用户需要输入身份信息、手机号和验证码等。 出现问题：页面已经写好了，可是在表单中使用v-model时出现了问题。应该响应用户输入的表单却不随着输入更新数据，导致提交时的表单信息没有更新。 代码分析在每个表单中都引用相应的v-model值，并在用户点击提交后，存放在cookie里，用户需要重复输入的时候读取cookie中已有的值，可以避免用户重复输入信息。1234567&lt;input type=\"tel\" placeholder=\"请输入您的手机号\" v-model=\"order.mobile\" /&gt;&lt;input type=\"number\" placeholder=\"请输入验证码\" v-model=\"order.verify_code\" /&gt;&lt;input type=\"text\" placeholder=\"请输入您的姓名\" v-model=\"order.real_name\" /&gt; . . .&lt;input type=\"text\" placeholder=\"请输入详细地址\" v-model=\"order.add_detail\"/&gt;表单代码如上，表单信息存在名为order的数据中，用户点击提交按钮后，把order存储在cookie中。现在展示vue的代码部分：1234567891011121314151617181920&lt;script&gt; data()&#123; return &#123; order:&#123;&#125; &#125; &#125;, methods: &#123; reload() &#123; this.order = getCookie('order') if(!this.order) this.order = &#123;&#125; this.order.verify_code = '' ... &#125; &#125;, route: &#123; data() &#123; this.reload() &#125; &#125;&lt;/script&gt;意思是，从cookie中取出order数据，如果cookie中没有order数据，就创建一个空的order，把验证码这一数据置空。路由切换的时候就执行reload()函数。 大致思路是没有问题的，可是测试时order.verify_code的值并不是表单中输入的值，而且也不随着表单输入的更新而更新数据。 更难以理解的bug是点击输入验证码后，点击其他表单进行输入时，刚才输入的验证码就会自动清空，有时会直接切换显示出上次输入的数据。 通过打印了一堆日志发现，order的值只在点击提交才会存储变更，这并不是我想要的结果。而且order的值并没有通过Vue生成对应的 getter/setter 属性。 列出疑问 为什么输入的数据会清空？ 为什么order.verify_code的数据不是动态响应用户输入的？ 为什么刷新页面后order.verify_code的值是刷新之前填写的值？ 为什么Vue不自动生成属性相对应的 getter/setter ？ 探索既是发现针对问题寻找答案我很清楚，问题肯定是出在reload()函数的代码中，但是究竟要怎么修改呢？为了找到出现这种状况的原因，我仔细研读了Vue的官方文档。下面就针对这次的问题科普下Vue的知识： 关于深入响应式原理，官方文档是这样写的： 如何追踪变化：把一个普通对象传给Vue实例作为它的data选项，Vue.js将遍历它的属性，用object.defineProperty将它们转为 getter/setter。 变化检测问题：受ES5的限制，Vue.js不能检测到对象属性的添加或删除。因为Vue.js在初始化实例时将属性转为 getter/setter，所以属性必须在data对象上才能让Vue.js转换它，才能让它是响应的。 Vue官方文档cn.vuejs.org/guide/reactivity.html例如：12345678var data = &#123;a:1&#125;var vm = new Vue(&#123; data:data&#125;) // vm.a 和 data.a 是响应的vm.b = 2 // 不响应data.b = 2 //不响应看到这里，我的疑惑就已经清晰了，原来文档中写的很清楚。 并且在data的API解释时，文档中也说明了：Vue实例的数据对象，Vue.js会递归地将它全部属性转换为 getter/setter，从而让它能响应数据变化。这个对象必须是普通对象，原生对象 getter/setter 及原型属性会被忽略。 Vue官方文档cn.vuejs.org/api/#data 所以原因出在，我没有在data中事先声明order中的各个属性，导致Vue在创建实例时没有遍历到这些参数从而转换成相应的 getter/setter ，也就无法检测到这些属性的变化。 更改问题代码找到了问题的根本，也理解的问题的发生原因，我需要修改我的代码。正确的代码应为是：12345678910111213141516171819202122232425262728293031&lt;script&gt;data()&#123; return &#123; order: &#123; verify_code: '', phone: '', real_name: '', ... add_detail: '' &#125; &#125;&#125;,methods: &#123; data()&#123; reload() &#123; let order_cookie = getCookie('order') if (order_cookie) &#123; this.order.phone = order_cookie.phone ... &#125; this.order.verify_code = '' ... &#125; &#125;&#125;,route: &#123; data() &#123; this.reload() &#125;&#125;&lt;/script&gt; 问题解决了，归根结底好像是我没有好好阅读官方文档的缘故，好尴尬呀～不过在这之后，我准备仔细看一遍官方文档，了解Vue深层运作的原理，分析一下源代码。 作为一个Vue初学者，差的还远呢。 解决方法不唯一同样，在浏览官方文档的时候，也发现了针对这次遇到的问题的另一个解决办法。俗话说嘛，条条大路通罗马，我们Vue的大神也留了另一条路让我们过坑。 还是引用官方文档的描述：有办法在实例创建之后添加属性并且让它是响应的。对于Vue实例，可以使用$set(key, value)实例方法： 12vm.$set(‘b’, 2)// vm.b 和 data.b 现在是响应的对于普通数据对象，可以使用全局方法Vue.set(object, key, value)： 12Vue.set(data, ‘c’, 3)// vm.c 和 data.c 现在是响应的有时你想向已有对象上添加一些属性，例如使用Object.assigh()或_.extend()添加属性。但是添加到对象上的新属性不会触发更新。这时，可以创建一个新对象，包含原对象的属性和新的属性： 12this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123;a:1, b:2&#125;)// 不使用 Object.assign(this.someObject, &#123;a:1, b:2&#125;) Vue官方文档cn.vuejs.org/guide/reactivity.html 参考文档 Vue官方文档-深入响应式原理","categories":[{"name":"技术","slug":"技术","permalink":"http://lemon23.me/categories/技术/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lemon23.me/tags/Vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://lemon23.me/categories/技术/"}]},{"title":"Hexo的过坑记","slug":"Hexo的过坑记","date":"2016-10-21T07:56:46.000Z","updated":"2016-11-21T08:51:10.000Z","comments":true,"path":"2016/10/21/Hexo的过坑记/","link":"","permalink":"http://lemon23.me/2016/10/21/Hexo的过坑记/","excerpt":"博客终于搭好了，就写一篇文章就来记录一下我是如何配置Hexo直到部署上线的。顺便写给我家的小胖子，留着以后过坑用，拿走不谢哟～ ^ ^","text":"博客终于搭好了，就写一篇文章就来记录一下我是如何配置Hexo直到部署上线的。顺便写给我家的小胖子，留着以后过坑用，拿走不谢哟～ ^ ^ 安装安装NodeHexo是基于node.js的，所以安装 Node 是必须的。 安装Git这个也是必须的，你需要把本地的hexo内容提交到github上。 申请Github账号去申请个Github账号，创建用来做博客的远程仓库、域名和服务器之类的，这个就不细说了，配置不会的话另行百度。 安装Hexo。 首先创建一个文件夹，存放hexo的配置文件（命名为Blog最直观）。 如果你不确定有没有安装过Hexo，或者之后需要查看它的版本，可以在终端输入： 1$ hexo version 然后打开终端，进入Blog文件夹 1$ cd Blog 运行下面的命令安装Hexo： 1$ sudo npm insall -g hexo 执行init命令初始化hexo： 1$ hexo init 现在，安装工作就结束了，Blog就是你博客的根目录，之后所有的操作都在这个文件夹下进行。 生成静态页面(该命令也可缩写为 $ hexo g) 1$ hexo generate 本地启动服务，进行预览： (该命令也可缩写为 $ hexo s) 1$ hexo server 在浏览器中输入终端打印出的路径，默认都是：http://localhost:4000 也可能是 http://0.0.0.0:4000 Hexo的基本使用 $ hexo new [layout] &lt;title&gt; 创建一篇新文章。其中layout是可选参数，默认值是post。Hexo提供的layout在scaffolds目录下，也可以在此目录下自建layout文件。新建的文件则会保存到 source/_post目录下。你也可以更改默认布局的参数，如post布局，你需要打开 scaffolds/post.md，增加类别和描述。再新建一篇文章就能看到增加了文章参数。 $ hexo generate 也可简写为$ hexo g 在部署前需要通过该命令把所有的文章做静态化处理，生成相应的html、javascript、css。 $ hexo deploy也可简写为$ hexo d 生成静态文件后要发布到github。在此之前要先配置好deploy指令，在全局配置文件(_config.yml)中找到deploy，并修改属性值： _config.yml123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/Lemon23/Lemon23.github.io.git branch: master 然后安装hexo-deployer-git： 1$ npm install hexo-deployer-git -S 最后利用hexo指令 $ hexo d 发布到github就完成了。在你的github的仓库中已经能看到刚刚部署的静态Web网站。 在这里要强调一下，如果部署的是个人页，新建的仓库必须是 your-user-name.github.io。具体创建仓库和申请github个人域名的步骤，这里就不细说了，很简单。 Hexo全局配置文件在Blog/_config.yml，这是全局配置文件，跟主题配置文件是不同的，千万别弄混了。 _config.yml1234567891011# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 站点配置title: Lemon 的博客 #网站标题subtitle: #网站副标题description: #网站描述author: #你的名字language: zh-CN #网站语言timezone: Asia/Shanghai #网站时区 中国的小伙伴们，时区你就这么填写就好了。 _config.yml123456# URL ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://lemon23.github.io #网址，搜索时会在搜索引擎中显示root: / #网站根目录permalink: :year/:month/:day/:title/ #永久链接格式permalink_defaults: #永久链接中各部分的默认值 关于url值的问题，如果你绑定使用的是Github，那么就填你github上的域名，例如：http://your-user-name.github.io。 _config.yml123456789# Directory 目录配置source_dir: source #资源文件夹，这个文件夹用来存放内容public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code文件夹i18n_dir: :lang #国际化文件夹skip_render: #跳过指定文件的渲染，可以使用glob来配置路径 这部分在你没完全搞懂Hexo的文件架构时，还是别乱改了，本宝宝也不敢轻易乱动。 _config.yml123456789101112131415# Writingnew_post_name: :title.md # File name of new postsdefault_layout: post #默认布局titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0 #把文件名转换为小写（1）或大写（2）render_drafts: false #显示草稿post_asset_folder: true #是否启动资源文件夹relative_link: false # 把链接更改为与根目录的相对位置future: truehighlight: #代码块设置 enable: true line_number: true auto_detect: false tab_replace: Hexo有三种默认布局：post、page和draft，它们分别对应不同的路径。新建文件的默认布局时post，你也可以更改或者在post.md文件中增加默认布局参数。 _config.yml1234# Category &amp; Tag 分类和标签default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名 这个不用做什么更改，也不是所有参数都要有值的。 _config.yml123456# Date / Time format 时间和日期## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss 可以改成你喜欢或习惯的时间格式，看着高兴怎么改都成。 _config.yml1234# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章数量（0=关闭分页功能）pagination_dir: page #分页目录 不想页面显示太长的可以把数字改小。 _config.yml1234# Extensions 扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus #当前主题名称 在这里更改你的主题名称，要提前配置好主题配置文件。 _config.yml123456# Deployment 部署到github## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/Lemon23/Lemon23.github.io.git branch: master 相对应的填写你自己的github地址和仓库分支。 Hexo更改主题配置到hexo后运行$ hexo s可以开启本地服务，进行浏览。打开页面后你会发现，这XX的也太丑了！对啦，所以现在的问题就是我们如何更改hexo的主题。 Hexo提供了大量的主题可供选择，主题的配置方法也不尽相同，但大概思路是差不多的，使用量最多的主题该署 hexo-theme-next了，随便一百度就有大把的教程。 你可以去下面列出的地方挑选喜欢的主题，基本上发布主题的人都会在仓库的wiki里讲解该主题怎么安装和一些配置问题。如果没有说明的地方可以再另行百度，毕竟人和人的需求不一样，文档也不可能符合每个人的要求。 知乎-有哪些好看的Hexo主题？ hexo-wiki-Themes 官方样式文档 hexo-theme-icarus我使用的主题是: hexo-theme-icarus 这个主题属于清新、简约的感觉，内置评论功能。接下来我就要讲这款主题怎么配置，如果你选择的是其他的主题，配置过程也大同小异，动动脑子动动手指，尽享无数主题。 icarus 的配置发布者已经把基本的配置步骤写在了wiki里，还包括FQA，如果有什么解决不了的问题也可以到https://github.com/ppoffice/hexo-theme-icarus/wiki去提问，或看有没有和你同样问题的回答。 Install 在你的终端中先进入Blog目录，创建themes/icarus主题文件夹路径，输入下列命令： 1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 更改全局配置文件(_config.yml)的theme属性为：theme: icarus 重命名主题配置文件_config.yml.example 为 _config.yml 别忘了检查你的主题版本是不是最新的： 12$ cd themes/icarus$ git pull 如果你的博客中需要添加搜索功能，你需要先安装hexo-generator-json-content： 1$ npm install -S hexo-generator-json-content 编辑_config.yml我分部看一下示例主题配置文件的内容，我再细细讲解每个属性的意思：_config.yml1234567# Menus 导航栏menu: Home: . #主页 Archives: archives #时间轴 Categories: categories #分类 Tags: tags #标签 About: about #关于你这部分就是博客导航栏的规划，之后你也可以自行编辑导航都显示什么，或者更改他们的路径。这里要说的是，主题只生成主页和时间轴的页面，其余的你要根据自己的需要自己生成页面文件。你可以使用相对路径，也可以使用绝对路径。 _config.yml1234567891011121314151617181920212223242526# Customize 私人订制customize: logo: #博客logo的设置 enabled: true width: 40 height: 40 url: images/logo.png #可以更改为你自己的logo图片，存在themes/icarus/source/css/images下 profile: #个人信息的设置，默认显示在左侧的那一栏信息。 enabled: true # Whether to show profile bar avatar: css/images/avatar.png gravatar: # Gravatar email address, if you enable Gravatar, your avatar config will be overriden author: PPOffice author_title: Web Developer &amp; Designer location: Harbin, China follow: https://github.com/ppoffice/ highlight: monokai #代码高亮样式，可以在themes/icarus/source/css/_heighlight中选择喜欢的样式 sidebar: right # sidebar position, options: left, right thumbnail: true # enable posts thumbnail, options: true, false favicon: # path to favicon social_links: #这是关注栏，填写你自己的各种网站的地址 github: http://github.com/ppoffice/hexo-theme-icarus twitter: / facebook: / dribbble: / rss: / social_link_tooltip: true # enable the social link tooltip, options: true, false 这里没什么好说的，相应的改为你自己的信息。_config.yml12345678# Widgets #右侧边栏设置widgets: - recent_posts - category - archive - tag - tagcloud - links这里是右侧边栏的显示配置，到时候你可以打开博客自己看，就是归档、标签云和链接之类的，如果你不想要哪个部分，就在这里删除它。_config.yml12345# Search #搜索配置search: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: false # you need to disable other search engines to use Baidu search, options: true, false需要先安装hexo-generator-json-content，上面讲过了。_config.yml12345# Comment #评论配置comment: disqus: hexo-theme-icarus # enter disqus shortname here duoshuo: # enter duoshuo shortname here youyan: # enter youyan uid here如果需要开启评论功能，需要先去相应的地方注册账号，然后按照提示把ID或名字添加上。点击这里 跟着做就对了。剩下一些评论框自定义的样式就自行百度，或注册后在网站内进行更改设置就好了。_config.yml12# Share 分享设置share: default # options: jiathis, bdshare, addtoany, default提供了几个参数可供选择，你可以 点击这里 看到各种参数的样式，进行选择和更改。_config.yml123456# Plugins 相册设置plugins: lightgallery: true # options: true, false google_analytics: # enter the tracking ID for your Google Analytics google_site_verification: # enter Google site verification code baidu_analytics: # enter Baidu Analytics hash key主题内置了相册功能，一般不用做什么更改了，其他的可以参考这里_config.yml123456789# Miscellaneous 其他miscellaneous: open_graph: # see http://ogp.me fb_app_id: fb_admins: twitter_id: google_plus: links: Hexo: http://hexo.io这里没什么好改的，参考这里 进行到这里，你的博客样式已经改好了，运行hexo g和hexo s本地浏览下效果吧。接下来的工作就是你自定义样式了，主题样式文件都在themes/icarus/source/css/_partial里，对照着页面文件找到对应的class样式去修改吧。 发布文章创建文章 $ hexo new &quot;我的第一次提交&quot; 打开source/_post目录下的我的第一次提交.md编辑内容 启动本地服务，浏览效果 编辑文章内容，需要你学会 Markdown 格式，还有些格式问题可以直接百度去搜索，多写一些文章自然就记下了各种格式标签。 这里说一个小技巧： 发布的文章较长时，主页会全部显示出来，页面也会变得很长。这个时候我们在编辑内容时，在合适的地方添加一行代码：&lt;!-- more --&gt;，在它之上是摘要，是在主页会显示的文字部分。在它之下是余下全文，在主页中会多一个阅读全文的按钮，点击后才会看到全部内容。 这样就避免了主页显示不必要的内容，占据大量篇幅。 文章参数打开 scaffolds/post.md 增加类别和描述，修改默认布局的参数：post.md12345678910---title: #标题date: #日期时间tags: #标签categories: #分类comments: #是否允许评论 true 或 falsetoc: #是否添加文章目录 true 或 falsethumbnail: #侧边栏封面图banner: #文章顶部封面图---在新建一篇文章，你就能看到新建的文章已经新增了这些参数，不用每次自己手打，不需要的值就可以空着。 其中tags和categories有多个值，用数组的形式写入。 thumbnail是主页侧边栏的展示图，这里如果不给定值，Hexo自动显示默认图片。 banner是文章的顶部封面图，在主页也会展示，如果不给定值就不显示。 图片都放在source/images中，如果没有这个文件夹就新建一个，在这里存放文章中会用到的图片。 注意！引用图片路径时，一定要以/开头，例如：/images/img1.jpeg 这样，无论是在主页或者打开文章都可以显示图片。 绑定自定义域名现在你在浏览器输入http://your-user-name.github.io就能显示你的博客了吧，那么如果想要使用自己的域名访问要怎么弄呢？接下来我就讲一下域名和github绑定的问题。 首先，你要有自己的域名。如果还没有就去买一个，购买域名可以去GoDaddy或者万网 注册DNSpod，添加域名，添加记录，如下图： 在source文件夹里创建CNAME文件，不要带任何后缀，在里面写入你的域名，例如：lemon23.me（前面不要加http://） 然后就在终端输入$ hexo d -g 试试吧 我也是刚搭建好这个博客，如果有写错的地方还请多多见谅，提出意见，我会及时更改的。 补充之前遇到了一个问题，就是Hexo的图标等加载不出来，打开控制器发现是位于vender文件夹下的样式文件加载不到。原因竟是github的升级导致的，icarus主题的作者已经更新了代码，小伙伴们git pull一下就好了。 参考资料和其他 Hexo-theme-icarus/wiki 主题官方文档 简洁轻便的博客平台: Hexo配置详解 NexT主题与Hexo更搭哦（基础篇） 给你的Hexo站点添加最近访客（多说篇） 给hexo配置上评论和访问量 Hexo博客优化，如何加快你的博客访问速度(精) Hexo站点中添加文章目录以及归档 域名和github绑定的问题 Hexo Docs","categories":[{"name":"技术","slug":"技术","permalink":"http://lemon23.me/categories/技术/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://lemon23.me/tags/Hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://lemon23.me/categories/技术/"}]}]}